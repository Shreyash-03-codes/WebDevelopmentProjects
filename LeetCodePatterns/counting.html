<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Counting Algorithm By Algo Masters</title>
    <link rel="shortcut icon" href="/Images/logo.jpeg" type="image/x-icon">
    <style>
 
    
        .def{
            font-size: 25px;
        }
        .twopointers{
            margin-bottom: 10px;
        }
        .intuition{
            display: flex;
            flex-direction: row;
            justify-content: space-around;
        }

        .def{
            width: 50%;
            height: 50%;
        }
        .definition{
            font-size: 25px;
        }
    
        .datastructures li{
            
            padding-left: 0px;
            font-size: 25px;
            line-height: 40px;
        }
        .code{
            font-size: 20px;
            margin-top: 4%;
        }
        .image{
            margin-left: 10%;
        }
        .code p{
            font-weight: 600;
            font-size: 24px;
        }
        .javacode{
            border: 2px solid black;
            background-color: rgb(246, 243, 241);
        }
        .javacode pre{
            font-weight: 500;
            color: rgba(6, 6, 6, 0.986);
            line-height: 30px;
        }
        .output{
            border-top: 1px solid black;
            padding: 30px;
            background-color: rgb(244, 241, 238);;
        }
        .explanation ol{
            font-size: 25px;
            line-height: 40px;
        }
        .explanation ol h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .execution ol{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }
        .execution ol h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .timecomplexity ul h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .timecomplexity ul{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }

        .spacecomplexity ul h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .spacecomplexity ul{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }

        .adv ol h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .adv ol{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }
        .problems ol h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .problems ol{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }

    </style>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="container">
        <div class="navigation">
            <div class="nav">
              <ul>
                <li><img src="/Images/logo.jpeg" id="logo" alt="" /></li>
                <li id="namelogo">Algo Master`s</li>
                <li><a href="index.html" target="_blank">Home</a></li>
                <li><a href="patterns.html" target="_blank">Patterns</a></li>
                <li><a href="problems.html" target="_blank">Problems</a></li> 
                               <li>Contact</li>
           
              </ul>
            </div>
          </div>

          <div class="twopointers">
            <h1>Counting Algorithm</h1>
            <div class="definition">
                <p><strong>Definition:</strong>
                    The Counting Algorithm pattern is used to keep track of the frequency or occurrence of elements within a dataset. It often involves a data structure (like an array or hashmap) to store the count of each unique element, enabling quick access to the number of occurrences for each element.

</p>
                   
            </div>
          
            <div class="intuition">
                <div class="def">
                
                <p><strong>Intuition:</strong>
                    The intuition behind the Counting Algorithm is that by creating a structure to hold counts of each item, we can later perform efficient lookups, comparisons, and retrievals without repeatedly scanning the entire dataset. This approach is highly effective when the dataset elements have a limited range, allowing counting with an array, or when we want to quickly find frequencies or identify unique patterns.</p>
            </div>
            <div class="image">
                <img src="/Images/counting.webp" alt="Two Pointers" width="60%" height="60%">
            </div>
        </div>
           
          </div>

          <div class="datastructures">
            <ul><h1>Required Data Structures:</h1>
                <ul>
                    <li><strong>Array or HashMap:</strong> An array works well when elements are small integers within a fixed range (e.g., digits from 0 to 9). For more diverse data types or ranges, a hashmap can store counts with each unique element as a key</li>
                </ul>
            </ul>
          </div>

          <div class="explanation">
            <ol><h3>Algorithm:</h3>
             <p>The general algorithm for the Counting Algorithm pattern is as follows:</p>
             <ol>
                <li><strong>Initialize a Data Structure for Counting:</strong>
                <ul>
                    <li>Use an array (for small, bounded ranges) or a hashmap (for arbitrary elements) to store counts.
                    </li>
                </ul>
                </li>
                <li><strong>Iterate Through the Dataset:</strong>
                <ul>
                    <li>For each element in the dataset, increase its count in the counting structure by 1.</li>
                </ul>
                </li>
                <li><strong>Analyze the Counts:</strong>
                <ul><li>After building the count structure, examine the counts to find the desired result, like the most frequent element, elements with a specific count, or elements that appear only once.</li></ul>
                </li>
                <li><strong>Return the Results Based on Counts:</strong>
                <ul>
                    <li>Use the counts to build the final output, such as a list of top items, unique elements, or a boolean check.</li>
                </ul>
                </li>
             </ol>
            </ol>
         </div>
        <div class="code">
            <h2>Java Code Example:</h2>
            <p>Problem: Find the majority element (the element that appears more than N/2 times) in an array.</p>
            <div class="javacode">
                <pre>
    import java.util.HashMap;

    public class MajorityElement {
        public int findMajorityElement(int[] nums) {
            HashMap<Integer, Integer> countMap = new HashMap<>();
            
            // Count each element's occurrences
            for (int num : nums) {
                countMap.put(num, countMap.getOrDefault(num, 0) + 1);
            }
            
            // Find the majority element
            int majorityCount = nums.length / 2;
            for (int num : countMap.keySet()) {
                if (countMap.get(num) > majorityCount) {
                    return num;
                }
            }
            
            return -1; // Return -1 if no majority element exists (assuming input guarantees one)
        }
    }
                    
                    
                </pre>
                <div class="output">
                    <h3>Input:</h3>

                    <p>Array: [2, 2, 1, 1, 1, 2, 2]
                </p>
                    <h3>Output:</h3>
                    <p>Majority Element: 2</p>
                </div>
              
            </div>
           
        </div>

  

        <div class="execution">
            <ol><h3>Execution Steps:</h3>
                <ol>
                    <li><strong>Initialize the HashMap:</strong>
                    <ul>
                        <li>Start with an empty hashmap countMap where keys are elements and values are counts of occurrences.</li>
                    </ul>
                    </li>
                    <li><strong>Iterate Through Each Element in the Array:</strong>
                    <ul>
                        <li>For each element, update its count in countMap:
                        <ul>
                            <li>If the element is already present, increase its count by 1</li>
                            <li>If not, add it to the hashmap with an initial count of 1.</li>
                        </ul>

                        </li>
                    </ul>
                    </li>
                    <p>Example Execution <br>
                        For the array [2, 2, 1, 1, 1, 2, 2]:</p>

                        <ol>
                            <li><strong>After processing all elements, countMap will be:</strong>
                            <ul>
                                <li>{2: 4, 1: 3}</li>
                            </ul>
                            </li>
                            <li><strong>Analyze Counts to Find Majority Element:</strong>
                            <ul>
                                <li>Set majorityCount as N / 2 where N = 7, so majorityCount = 3.</li>
                                <li>Iterate over countMap:

                                    <ul>
                                        <li>Element 2 has a count of 4, which is greater than 3, so 2 is the majority element.</li>
                                    </ul>
                                </li>
                                
                            </ul>
                            
                            </li>
                        </ol>

            
                </ol>
            </ol>
        </div>
        <div class="complexity">
        <div class="timecomplexity">
            <ul>
                <h3>Time Complexity:</h3>
                <p>The time complexity of counting algorithms is typically:

                </p>
                <li>O(N), where 
                    
                    N is the size of the dataset, because each element is counted once in a single pass</li>
            </ul>
        </div>

        <div class="spacecomplexity">
           
            <ul>
                <h3>Space Complexity:</h3>
                <p>The space complexity depends on the range of unique elements:</p>
                <li>O(M), where 
                    
                    M is the number of unique elements in the dataset. For integer ranges with fixed bounds, space can be 
                    O(1), as the count array size is fixed.</li>
            </ul>
        </div>
    </div>

    <div class="theory">
        <div class="adv">
            <ol>
                <h3>Advantages:</h3>
                <ol>
                    <li><strong>Efficient Counting:</strong> Linear time complexity makes counting algorithms fast for single-pass problems.</li>
                    <li><strong>Flexible for Range-Bounded Problems:</strong> Arrays provide constant-time access for integer-bounded values, making them highly efficient.</li>
                    <li><strong>Direct Access to Frequencies:</strong>Direct Access to Frequencies: With a counting structure, we can instantly access the count of any element, which is useful for frequency-based analysis.</li>
                </ol>
            </ol>
        </div>
        <div class="adv">
            <ol><h3>Disadvantages:</h3>
                <ol>
                    <li><strong>Memory Usage:</strong> Space complexity depends on the range of elements. A hashmap may use more memory than direct indexing with arrays.</li>
                    <li><strong>Limited to Count-Based Problems:</strong> Counting algorithms are not directly useful for tasks that don’t involve frequencies.</li>
                    <li><strong>Range Limitations: </strong>Arrays for counting are limited to problems with known, bounded ranges. For arbitrary data types, hashmaps may introduce additional overhead.</li>
                </ol>
            </ol>
        </div>
        <div class="adv">
            <ol><h3>Applications:</h3>
                <ol>
                    <li><strong>Majority Element and Mode:</strong> Finding the most frequent or majority element in a dataset</li>
                    <li><strong>Duplicate Detection:</strong> Identifying duplicates by counting occurrences.</li>
                    <li><strong>Counting Sort:</strong> A sorting algorithm that counts occurrences to sort elements, especially effective with small range</li>
                    <li><strong>Element Frequency Analysis:</strong> Checking if two datasets have similar elements or distributions.</li>
                    <li><strong>Frequency-Based Filtering:</strong> Removing or filtering elements based on counts (e.g., filter elements appearing more than K times).</li>
                </ol>
            </ol>
        </div>
    </div>

    <div class="problems">
        <ol><h3>Popular Problems on Counting:</h3>
            <li><a href="https://leetcode.com/problems/majority-element/description/?envType=problem-list-v2&envId=counting" target="_blank"><strong>Majority Element</strong></a></li>
            <li><a href="https://leetcode.com/problems/majority-element-ii/description/?envType=problem-list-v2&envId=counting" target="_blank"><strong>Majority Element II</strong></a></li>
            <li><a href="https://leetcode.com/problems/first-unique-character-in-a-string/description/?envType=problem-list-v2&envId=counting" target="_blank"><strong>First Unique Character in a String</strong></a></li>
            <li><a href="https://leetcode.com/problems/count-nice-pairs-in-an-array/description/?envType=problem-list-v2&envId=counting" target="_blank"><strong>Count Nice Pairs in an Array</strong></a></li>
            <li><a href="https://leetcode.com/problems/count-elements-with-strictly-smaller-and-greater-elements/description/?envType=problem-list-v2&envId=counting" target="_blank"><strong>Count Elements With Strictly Smaller and Greater Elements </strong></a></li>
            <li><a href="https://leetcode.com/problems/most-frequent-even-element/description/?envType=problem-list-v2&envId=counting" target="_blank"><strong> Most Frequent Even Element</strong></a></li>
        </ol>

    </div>
          <footer>
            <div  id="footer">
                <span><img id="footerlogo" src="/Images/logo.jpeg" alt="" height="40px" width="40px"></span>
                <span>Algo Master`s</span></br>
                <p>One stop Portal for Problem Solving Patterns</p></span>
    
                <table id="foottable">
                    <thead>
                        <tr class="tableheading">
                            <th>ABOUT US</th>
                            <th>SOCIAL</th>
                            <th>LEGAL</th>
                            <th>RESOURCES</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="tableheading">
                            <td>Our Team</td>
                            <td>Facebook</td>
                            <td>Privacy Policy</td>
                            <td>Blog</td>
                        </tr>
                        <tr  class="tableheading">
                            <td>Careers</td>
                            <td>Linked In</td>
                            <td>Cookie Policy</td>
                            <td>Knoledge Base</td>
                        </tr>
                        <tr class="tableheading">
                            <td>Contact us</td>
                            <td>Twitter</td>
                            <td>Terms of Service</td>
                            <td>Answers Hub</td>
                        </tr>
                        
                    </tbody>
                </table>
    
            </div>
    
        </footer>
    </div>
    
</body>
</html>