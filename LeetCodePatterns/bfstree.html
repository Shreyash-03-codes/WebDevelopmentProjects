<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breadth First Search (BFS) of Tree By Algo Masters</title>
    <link rel="shortcut icon" href="/Images/logo.jpeg" type="image/x-icon">
    <style>
 
    
        .def{
            font-size: 25px;
        }
        .twopointers{
            margin-bottom: 10px;
        }
        .intuition{
            display: flex;
            flex-direction: row;
            justify-content: space-between;
        }

        .def{
            width: 50%;
            height: 50%;
        }
        .definition{
            font-size: 25px;
        }
    
        .datastructures li{
            
            padding-left: 0px;
            font-size: 25px;
            line-height: 40px;
        }
        .code{
            font-size: 20px;
            margin-top: 4%;
        }
        .code p{
            font-weight: 600;
            font-size: 24px;
        }
        .javacode{
            border: 2px solid black;
            background-color: rgb(246, 243, 241);
        }
        .javacode pre{
            font-weight: 500;
            color: rgba(6, 6, 6, 0.986);
            line-height: 30px;
        }
        .output{
            border-top: 1px solid black;
            padding: 30px;
            background-color: rgb(244, 241, 238);;
        }
        .explanation ol{
            font-size: 25px;
            line-height: 40px;
        }
        .explanation ol h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .execution ol{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }
        .execution ol h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .timecomplexity ul h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .timecomplexity ul{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }

        .spacecomplexity ul h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .spacecomplexity ul{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }

        .adv ol h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .adv ol{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }
        .problems ol h3{
            position: relative;
            right: 20px;
            top: 20px;
        }
        .problems ol{
            font-size: 25px;
            font-weight: 500;
            line-height: 40px;
        }

    </style>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="container">
        <div class="navigation">
            <div class="nav">
              <ul>
                <li><img src="/Images/logo.jpeg" id="logo" alt="" /></li>
                <li id="namelogo">Algo Master`s</li>
                <li><a href="index.html" target="_blank">Home</a></li>
                <li><a href="patterns.html" target="_blank">Patterns</a></li>
                <li><a href="problems.html" target="_blank">Problems</a></li>                <li>Contact</li>
           
              </ul>
            </div>
          </div>

          <div class="twopointers">
            <h1>Breadth First Search (BFS) of Tree </h1>
            <div class="definition">
                <p><strong>Definition:</strong>
                    BFS is a traversal algorithm that explores all nodes at the present depth level before moving on to nodes at the next depth level. It uses a First In, First Out (FIFO) data structure, such as a queue, to manage the order of node visits.</p>
                   
            </div>
          
            <div class="intuition">
                <div class="def">
                
                <p><strong>Intuition:</strong>
                    The intuition behind BFS is to visit all nodes at the current level before moving to the next level. By processing nodes in this order, BFS ensures that each node's children are visited only after the node itself, resulting in a level-order traversal of the tree. BFS is particularly helpful when the solution requires the shortest path or all nodes at a given depth.</p>
            </div>
            <div class="twopointersimage">
                <img src="/Images/bfstree.gif"  alt="Two Pointers" width="60%" height="80%">
            </div>
        </div>
           
          </div>

          <div class="datastructures">
            <ul><h1>Required Data Structures:</h1>
                <ul>
                    <li><strong>Queue:</strong> A queue is essential to store nodes at the current level while adding their children for subsequent processing.</li>
                </ul>
            </ul>
          </div>

          <div class="explanation">
            <ol><h3>Algorithm:</h3>
             <ol>
                <ol>
                    <li><strong>Initialize the Queue:</strong>
                    <ul>
                        <li>Start by placing the root node into a queue.</li>
                    </ul>
                    </li>
                    <li><strong>Process Nodes Level by Level:</strong>
                    <ul>
                        <li>While the queue is not empty:

                            <ul>
                                <li>Remove a node from the front of the queue.</li>
                                <li>Process this node (print its value, etc.).</li>
                                <li>Add all children of this node to the back of the queue.</li>
                            </ul>
                        </li>
                    </ul>
                    </li>
                    <li><strong>Continue Until Queue is Empty:</strong>
                    <ul>
                        <li>Keep processing nodes level by level until all nodes are visited.</li>
                    </ul>
                    </li>
                </ol>
             </ol>
            </ol>
         </div>
        <div class="code">
            <h2>Java Code Example:</h2>
            <p>Problem: Perform BFS on a binary tree and print nodes in level-order.</p>
            <div class="javacode">
                <pre>
            import java.util.LinkedList;
            import java.util.Queue;

            class TreeNode {
                int val;
                TreeNode left;
                TreeNode right;
                TreeNode(int x) { val = x; }
            }

            public class TreeBFS {
                public void bfs(TreeNode root) {
                    if (root == null) return;

                    Queue<TreeNode> queue = new LinkedList<>();
                    queue.add(root);

                    while (!queue.isEmpty()) {
                        TreeNode currentNode = queue.poll(); // Remove and return the head of the queue
                        System.out.print(currentNode.val + " ");

                        // Add left and right children to the queue
                        if (currentNode.left != null) queue.add(currentNode.left);
                        if (currentNode.right != null) queue.add(currentNode.right);
                    }
                }
            }
                    
                    
                </pre>
                <div class="output">
                    <h3>Input:</h3>

                    <pre>
          1
         / \
        2   3
       / \   \
      4   5   6
                    </pre>
                    <h3>Output:</h3>
                    <p>Result: 1 2 3 4 5 6 (Level-order traversal)</p>
                </div>
              
            </div>
           
        </div>

  

        <div class="execution">
            <ol><h3>Execution Steps:</h3>
                <ol>
                    <li><strong>Initialize Queue with Root:

                    </strong>
                <ul>
                    <li>Add the root node 1 to the queue.
                    </li>
                </ul></li>
                    <li><strong>Process Nodes in Queue:

                    </strong>
                <ul>
                    <li>Remove 1 from the queue, print its value, and add its children (2 and 3) to the queue.
                    </li>
                    <li>Next, process 2, add its children (4 and 5) to the queue.
                    </li>
                    <li>Process 3, add its child 6 to the queue.
                    </li>
                </ul>
                </li>
                    <li><strong>Continue Until Queue is Empty:

                    </strong>
                <ul>
                    <li>Continue until all nodes are processed in level-order, giving the final order: 1 2 3 4 5 6.
                    </li>
                </ul>
                </li>
                </ol>

                <p>Example Execution for Tree Structure Above</p>
                <ol>
                    <li>Visit 1, add 2, 3 to the queue.</li>
                    <li>Visit 2, add 4, 5 to the queue.
                    </li>
                    <li>Visit 3, add 6 to the queue.
                    </li>
                    <li>Visit 4 (leaf).
                    </li>
                    <li>Visit 5 (leaf).
                    </li>
                    <li>Visit 6 (leaf).
                    </li>
                </ol>
                <p>Final result: 1 2 3 4 5 6.</p>
            </ol>
        </div>
        <div class="complexity">
        <div class="timecomplexity">
            <ul>
                <h3>Time Complexity:</h3>
            <ul>
                <li><strong>BFS of Tree:</strong>   
                 O(N), where  N is the number of nodes in the tree, as each node is visited once.</li>
            </ul>
            </ul>
        </div>

        <div class="spacecomplexity">
           
            <ul>
                <h3>Space Complexity:</h3>
                <ul>
                    <li><strong>BFS Queue:</strong> 
                        O(W), where W is the maximum width of the tree (i.e., the maximum number of nodes at any level). In a balanced binary tree, this is O(N/2)=O(N), but often O(W) is much smaller in practice.</li>
                </ul>
            </ul>
        </div>
    </div>

    <div class="theory">
        <div class="adv">
            <ol>
                <h3>Advantages:</h3>
                <ol>
                    <li><strong>Shortest Path Discovery:</strong> BFS is ideal for finding the shortest path in unweighted trees and graphs.
                    </li>
                    <li><strong>Level-by-Level Processing:</strong> BFS naturally processes nodes by levels, making it suitable for applications that require depth awareness</li>
                    <li><strong>Uniformly Searches Tree:</strong> BFS explores all nodes at one level before moving deeper, ensuring no deeper node is processed before shallow ones</li>
                </ol>
            </ol>
        </div>
        <div class="adv">
            <ol><h3>Disadvantages:</h3>
                <ol>
                    <li><strong>Higher Memory Use:</strong> BFS requires a queue to store nodes at each level, which can lead to high memory usage if the tree has a large width.
                    </li>
                    <li><strong>Less Suitable for Deep Trees:</strong> For trees with a large depth, BFS can be less efficient due to potential memory consumption.
                    </li>
                    <li><strong>Not Ideal for Path Exploration:</strong> Unlike DFS, BFS is less efficient for exploring deep paths in problems where backtracking may be required.
                    </li>
                </ol>
            </ol>
        </div>
        <div class="adv">
            <ol><h3>Applications:</h3>
                <ol>
                    <li><strong>Shortest Path in Unweighted Trees/Graphs:</strong> BFS finds the shortest path to a target node by exploring all nodes at each level before moving deeper.
                    </li>
                    <li><strong>Level-Order Traversal:</strong> BFS naturally performs level-order traversal, making it ideal for printing tree nodes level by level.
                    </li>
                    <li><strong>Breadth-First Tree and Graph Algorithms:</strong> BFS is foundational for algorithms that require processing nodes in breadth-first order, like finding connected components.
                    </li>
                    <li><strong>Problem Solving in Grid-Based Games:</strong> BFS helps to explore reachable positions from a starting point, such as in games and mazes.
                    </li>
                    <li><strong>Checking if a Graph is Bipartite:</strong> BFS is useful for determining if a graph can be colored with two colors (bipartiteness).
                    </li>
                    <li><strong>Finding Connected Components:</strong> In undirected graphs, BFS can be used to explore all nodes connected to a given node.
                    </li>

                    <p>The Breadth-First Search (BFS) pattern is well-suited for problems requiring level-by-level exploration, shortest path determination in unweighted graphs, and applications where a global view of all nodes at each depth is needed.
                    </p>
                </ol>
            </ol>
        </div>
    </div>

    <div class="problems">
        <ol><h3>Popular Problems on Breadth First Search (BFS) of Tree</h3>
            <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/?envType=problem-list-v2&envId=breadth-first-search" target="_blank"><strong> Binary Tree Level Order Traversal</strong></a></li>
            <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/?envType=problem-list-v2&envId=breadth-first-search" target="_blank"><strong> Binary Tree Level Order Traversal II</strong></a></li>
            <li><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/?envType=problem-list-v2&envId=breadth-first-search" target="_blank"><strong>Binary Tree Zigzag Level Order Traversal</strong></a></li>
            <li><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/?envType=problem-list-v2&envId=breadth-first-search" target="_blank"><strong>N-ary Tree Level Order Traversal</strong></a></li>
            <li><a href="https://leetcode.com/problems/maximum-width-of-binary-tree/description/?envType=problem-list-v2&envId=breadth-first-search" target="_blank"><strong>Maximum Width of Binary Tree</strong></a></li>
            <li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/?envType=problem-list-v2&envId=breadth-first-search" target="_blank"><strong>Populating Next Right Pointers in Each Node</strong></a></li>
        </ol>

    </div>
          <footer>
            <div  id="footer">
                <span><img id="footerlogo" src="/Images/logo.jpeg" alt="" height="40px" width="40px"></span>
                <span>Algo Master`s</span></br>
                <p>One stop Portal for Problem Solving Patterns</p></span>
    
                <table id="foottable">
                    <thead>
                        <tr class="tableheading">
                            <th>ABOUT US</th>
                            <th>SOCIAL</th>
                            <th>LEGAL</th>
                            <th>RESOURCES</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="tableheading">
                            <td>Our Team</td>
                            <td>Facebook</td>
                            <td>Privacy Policy</td>
                            <td>Blog</td>
                        </tr>
                        <tr  class="tableheading">
                            <td>Careers</td>
                            <td>Linked In</td>
                            <td>Cookie Policy</td>
                            <td>Knoledge Base</td>
                        </tr>
                        <tr class="tableheading">
                            <td>Contact us</td>
                            <td>Twitter</td>
                            <td>Terms of Service</td>
                            <td>Answers Hub</td>
                        </tr>
                        
                    </tbody>
                </table>
    
            </div>
    
        </footer>
    </div>
    
</body>
</html>